name: üó≥Ô∏è Vote Automation 24/7

on:
  schedule:
    # Vote 24/7 toutes les 1h30 (16 votes par jour)
    # Utilise environ 2400 minutes/mois sur les 3000 disponibles avec GitHub Pro
    - cron: "0 0 * * *" # 00h00
    - cron: "30 1 * * *" # 01h30
    - cron: "0 3 * * *" # 03h00
    - cron: "30 4 * * *" # 04h30
    - cron: "0 6 * * *" # 06h00
    - cron: "30 7 * * *" # 07h30
    - cron: "0 9 * * *" # 09h00
    - cron: "30 10 * * *" # 10h30
    - cron: "0 12 * * *" # 12h00
    - cron: "30 13 * * *" # 13h30
    - cron: "0 15 * * *" # 15h00
    - cron: "30 16 * * *" # 16h30
    - cron: "0 18 * * *" # 18h00
    - cron: "30 19 * * *" # 19h30
    - cron: "0 21 * * *" # 21h00
    - cron: "30 22 * * *" # 22h30

  workflow_dispatch: # Permet de d√©clencher manuellement pour les tests
    inputs:
      test_mode:
        description: "Mode test (true/false)"
        required: false
        default: "false"

jobs:
  vote:
    runs-on: ubuntu-latest
    timeout-minutes: 10 # R√©duit pour √©viter les annulations pendant Cloudflare

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üêç Setup Python 3.9
        uses: actions/setup-python@v5
        with:
          python-version: "3.9"

      - name: üì¶ Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: üîß Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y wget unzip xvfb

      - name: üåê Install Google Chrome
        run: |
          wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
          sudo sh -c 'echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" >> /etc/apt/sources.list.d/google.list'
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable

          # V√©rifier l'installation
          google-chrome --version

      - name: üöó Install ChromeDriver
        run: |
          # Obtenir la version exacte de Chrome install√©e
          CHROME_VERSION=$(google-chrome --version | cut -d " " -f3)
          echo "Chrome version detected: $CHROME_VERSION"

          # Utiliser la m√™me version pour ChromeDriver
          CHROMEDRIVER_VERSION="$CHROME_VERSION"
          echo "Downloading ChromeDriver version: $CHROMEDRIVER_VERSION"

          # T√©l√©charger depuis la nouvelle API Chrome for Testing
          wget -O /tmp/chromedriver.zip "https://storage.googleapis.com/chrome-for-testing-public/$CHROMEDRIVER_VERSION/linux64/chromedriver-linux64.zip"

          # V√©rifier si le t√©l√©chargement a r√©ussi, sinon utiliser une version de fallback
          if [ $? -ne 0 ]; then
            echo "‚ùå Version exacte non trouv√©e, tentative avec version 138.0.7204.168"
            CHROMEDRIVER_VERSION="138.0.7204.168"
            wget -O /tmp/chromedriver.zip "https://storage.googleapis.com/chrome-for-testing-public/$CHROMEDRIVER_VERSION/linux64/chromedriver-linux64.zip"
          fi

          # Si √ßa √©choue encore, utiliser la derni√®re version stable 138
          if [ $? -ne 0 ]; then
            echo "‚ùå Tentative avec version stable 138"
            CHROMEDRIVER_VERSION="138.0.7204.169"
            wget -O /tmp/chromedriver.zip "https://storage.googleapis.com/chrome-for-testing-public/$CHROMEDRIVER_VERSION/linux64/chromedriver-linux64.zip"
          fi

          # Extraire et installer
          sudo unzip /tmp/chromedriver.zip -d /tmp/
          sudo mv /tmp/chromedriver-linux64/chromedriver /usr/local/bin/
          sudo chmod +x /usr/local/bin/chromedriver

          # V√©rifier l'installation
          chromedriver --version

      - name: üìö Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: üîë Use existing .env file
        run: |
          # V√©rifier que le fichier .env existe et contient l'API key
          if [ ! -f .env ]; then
            echo "‚ùå ERREUR: Fichier .env non trouv√©"
            exit 1
          fi

          if ! grep -q "api_key\|TWOCAPTCHA_API_KEY" .env; then
            echo "‚ùå ERREUR: API key non trouv√©e dans .env"
            exit 1
          fi

          echo "‚úÖ Fichier .env trouv√© et valide"

      - name: üó≥Ô∏è Execute vote script
        run: |
          echo "üöÄ D√©marrage du vote automatique..."
          echo "‚è∞ Heure actuelle: $(date)"
          echo "üåç Timezone: $(date +%Z)"

          # Lancer le script avec retry automatique et timeout
          for attempt in {1..3}; do
            echo "üîÑ Tentative $attempt/3..."
            
            # Essayer d'abord avec le nouveau script Cloudflare Bypass
            if timeout 300 python3 mtcaptcha_cloudflare_bypass.py --headless; then
              echo "üéâ Vote r√©ussi avec Cloudflare Bypass!"
              echo "VOTE_SUCCESS=true" >> $GITHUB_ENV
              break
            fi
            
            # Si √©chec, essayer avec SeleniumBase UC Mode
            if timeout 300 python3 mtcaptcha_seleniumbase.py --headless; then
              echo "üéâ Vote r√©ussi avec SeleniumBase!"
              echo "VOTE_SUCCESS=true" >> $GITHUB_ENV
              break
            fi
            
            # En dernier recours, essayer l'ancienne m√©thode am√©lior√©e
            if timeout 300 python3 mtcaptcha_github_actions.py --headless; then
              echo "üéâ Vote r√©ussi √† la tentative $attempt"
              echo "VOTE_SUCCESS=true" >> $GITHUB_ENV
              break
            else
              exit_code=$?
              echo "‚ùå √âchec √† la tentative $attempt (code: $exit_code)"
              
              # Si c'est un timeout (code 124), le mentionner
              if [ $exit_code -eq 124 ]; then
                echo "‚è±Ô∏è Timeout apr√®s 5 minutes"
              fi
              
              if [ $attempt -lt 3 ]; then
                echo "‚è≥ Attente de 20 secondes avant la prochaine tentative..."
                sleep 20
              else
                echo "üí• Toutes les tentatives ont √©chou√©"
                echo "VOTE_SUCCESS=false" >> $GITHUB_ENV
                # Ne pas faire exit 1 pour permettre l'upload des artifacts
              fi
            fi
          done
        env:
          DISPLAY: ":99"
          PYTHONUNBUFFERED: "1"

      - name: üìä Job Summary
        if: always()
        run: |
          echo "## üó≥Ô∏è Vote Automation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Date/Heure**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **R√©sultat**: ${{ env.VOTE_SUCCESS == 'true' && '‚úÖ Succ√®s' || '‚ùå √âchec' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: ${{ runner.os }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow**: ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ env.VOTE_SUCCESS }}" = "true" ]; then
            echo "- **Status**: üéâ Vote effectu√© avec succ√®s" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status**: ‚ö†Ô∏è Vote √©chou√© - v√©rifier les logs" >> $GITHUB_STEP_SUMMARY
          fi

      - name: üì∏ Upload screenshots on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: vote-failure-${{ github.run_number }}
          path: |
            *.log
            *.png
            screenshots/
          retention-days: 7

      - name: üîî Notify on failure (optionnel)
        if: failure()
        run: |
          # V√©rifier si un webhook Discord est configur√© dans .env
          if [ -f .env ] && grep -q "DISCORD_WEBHOOK" .env; then
            DISCORD_WEBHOOK=$(grep "DISCORD_WEBHOOK" .env | cut -d'=' -f2)
            if [ -n "$DISCORD_WEBHOOK" ]; then
              curl -X POST -H 'Content-type: application/json' \
              --data "{\"content\":\"‚ùå Vote automation failed at $(date)\\nWorkflow: ${{ github.workflow }}\\nRun: ${{ github.run_id }}\"}" \
              "$DISCORD_WEBHOOK"
              echo "Notification Discord envoy√©e"
            fi
          else
            echo "Discord webhook not configured, skipping notification"
          fi
